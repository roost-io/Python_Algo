# ********RoostGPT********
"""
Test generated by RoostGPT for test python-unit using AI Type Claude AI and AI Model claude-3-opus-20240229

ROOST_METHOD_HASH=make_allpass_aa18b576e9
ROOST_METHOD_SIG_HASH=make_allpass_aa18b576e9

Here are the pytest test scenarios for the provided make_allpass function:

Scenario 1: Valid All-Pass Filter Creation
Details:
  TestName: test_valid_allpass_filter_creation
  Description: Verify that the make_allpass function creates a valid all-pass filter with the correct coefficients when provided with valid input parameters.
Execution:
  Arrange: Import the necessary modules and define the input parameters (frequency, samplerate, and q_factor).
  Act: Call the make_allpass function with the defined input parameters.
  Assert: Check that the returned IIRFilter object has the expected number of coefficients and that the coefficients match the expected values.
Validation:
  This test ensures that the make_allpass function correctly calculates and sets the filter coefficients based on the provided input parameters, adhering to the mathematical formulas and business logic defined in the function.

Scenario 2: Default Q-Factor Value
Details:
  TestName: test_default_q_factor_value
  Description: Verify that the make_allpass function uses the default value of 1/sqrt(2) for the q_factor parameter when it is not provided.
Execution:
  Arrange: Import the necessary modules and define the input parameters (frequency and samplerate).
  Act: Call the make_allpass function with only the frequency and samplerate parameters.
  Assert: Check that the returned IIRFilter object has the expected coefficients, calculated using the default q_factor value.
Validation:
  This test ensures that the make_allpass function correctly handles the case when the q_factor parameter is not provided, using the default value as specified in the function signature.

Scenario 3: Boundary Frequency Values
Details:
  TestName: test_boundary_frequency_values
  Description: Verify that the make_allpass function creates valid all-pass filters for boundary frequency values (e.g., 0 Hz and Nyquist frequency).
Execution:
  Arrange: Import the necessary modules and define the input parameters (boundary frequency values and samplerate).
  Act: Call the make_allpass function with the boundary frequency values and samplerate.
  Assert: Check that the returned IIRFilter objects have the expected coefficients for the boundary frequency values.
Validation:
  This test ensures that the make_allpass function handles boundary frequency values correctly and creates valid all-pass filters without any errors or unexpected behavior.

Scenario 4: Extreme Q-Factor Values
Details:
  TestName: test_extreme_q_factor_values
  Description: Verify that the make_allpass function creates valid all-pass filters for extreme q_factor values (e.g., very small and very large values).
Execution:
  Arrange: Import the necessary modules and define the input parameters (frequency, samplerate, and extreme q_factor values).
  Act: Call the make_allpass function with the defined input parameters.
  Assert: Check that the returned IIRFilter objects have the expected coefficients for the extreme q_factor values.
Validation:
  This test ensures that the make_allpass function handles extreme q_factor values correctly and creates valid all-pass filters without any errors or unexpected behavior.

Scenario 5: Coefficient Symmetry
Details:
  TestName: test_coefficient_symmetry
  Description: Verify that the make_allpass function creates an all-pass filter with symmetric coefficients.
Execution:
  Arrange: Import the necessary modules and define the input parameters (frequency, samplerate, and q_factor).
  Act: Call the make_allpass function with the defined input parameters.
  Assert: Check that the returned IIRFilter object has symmetric a_coeffs and b_coeffs.
Validation:
  This test ensures that the make_allpass function adheres to the mathematical property of all-pass filters having symmetric coefficients, which is essential for maintaining the all-pass characteristics of the filter.

These test scenarios cover the essential aspects of the make_allpass function, including valid filter creation, default parameter handling, boundary and extreme input values, and coefficient symmetry. They ensure that the function behaves as expected and produces valid all-pass filters according to the specified business logic and mathematical requirements.
"""

# ********RoostGPT********
from math import cos, sin, sqrt, tau
from pytest import approx
from audio_filters.iir_filter import IIRFilter
from butterworth_filter import make_allpass

class TestButterworthFilterMakeAllpass:
    def test_valid_allpass_filter_creation(self):
        frequency = 1000
        samplerate = 48000
        q_factor = 0.5

        filter = make_allpass(frequency, samplerate, q_factor)

        assert isinstance(filter, IIRFilter)
        assert len(filter.a_coeffs) == 3
        assert len(filter.b_coeffs) == 3

        w0 = tau * frequency / samplerate
        _sin = sin(w0)
        _cos = cos(w0)
        alpha = _sin / (2 * q_factor)

        b0 = 1 - alpha
        b1 = -2 * _cos
        b2 = 1 + alpha

        assert filter.b_coeffs == approx([b0, b1, b2])
        assert filter.a_coeffs == approx([b2, b1, b0])

    def test_default_q_factor_value(self):
        frequency = 1000
        samplerate = 48000

        filter = make_allpass(frequency, samplerate)

        assert isinstance(filter, IIRFilter)
        assert len(filter.a_coeffs) == 3
        assert len(filter.b_coeffs) == 3

        w0 = tau * frequency / samplerate
        _sin = sin(w0)
        _cos = cos(w0)
        alpha = _sin / (2 * (1 / sqrt(2)))

        b0 = 1 - alpha
        b1 = -2 * _cos
        b2 = 1 + alpha

        assert filter.b_coeffs == approx([b0, b1, b2])
        assert filter.a_coeffs == approx([b2, b1, b0])

    def test_boundary_frequency_values(self):
        samplerate = 48000
        q_factor = 0.5

        # Test 0 Hz frequency
        filter_0hz = make_allpass(0, samplerate, q_factor)
        assert filter_0hz.b_coeffs == approx([1.0, -2.0, 1.0])
        assert filter_0hz.a_coeffs == approx([1.0, -2.0, 1.0])

        # Test Nyquist frequency
        nyquist_freq = samplerate // 2
        filter_nyquist = make_allpass(nyquist_freq, samplerate, q_factor)
        assert filter_nyquist.b_coeffs == approx([1.0, 2.0, 1.0])
        assert filter_nyquist.a_coeffs == approx([1.0, 2.0, 1.0])

    def test_extreme_q_factor_values(self):
        frequency = 1000
        samplerate = 48000

        # Test very small q_factor
        filter_small_q = make_allpass(frequency, samplerate, 1e-6)
        assert isinstance(filter_small_q, IIRFilter)
        assert len(filter_small_q.a_coeffs) == 3
        assert len(filter_small_q.b_coeffs) == 3

        # Test very large q_factor
        filter_large_q = make_allpass(frequency, samplerate, 1e6)
        assert isinstance(filter_large_q, IIRFilter)
        assert len(filter_large_q.a_coeffs) == 3
        assert len(filter_large_q.b_coeffs) == 3

    def test_coefficient_symmetry(self):
        frequency = 1000
        samplerate = 48000
        q_factor = 0.5

        filter = make_allpass(frequency, samplerate, q_factor)

        assert filter.b_coeffs == approx(filter.a_coeffs[::-1])
